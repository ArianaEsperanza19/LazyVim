{
  "Funci√≥n Main Principal": {
    "prefix": "main",
    "body": [
      "fn main() {",
      "\t$0",
      "}"
    ],
    "description": "Inserta la funci√≥n principal 'fn main() {}'"
  },
  
  "Cabecera de Archivo Rust": {
    "prefix": "header",
    "body": [
      "// Nombre: ${1:nombre}.rs",
      "// Autor: Ariana Uribe",
      "// Descripci√≥n: ${2:Descripci√≥n del archivo}",
      ""
    ],
    "description": "Plantilla de cabecera de archivo con nombre, autor y descripci√≥n."
  },
  "forString": 
  { 
  "prefix": ["forstr"],
  "body": [
      "for i in ${1:ini}..${2:end} {",
      "    println!(\"{}\", ${3:string}.chars().nth(i).unwrap());",
      "}"
  ],
  "description": ["For especial para recorrer caracteres de una cadena de texto."]
  },
  "Rust Borrowing Rules": {
    "prefix": "rules",
    "body": [
        "/* ",
        "#########################################################################",
        "#                               REGLAS DE RUST: PROPIEDAD Y PR√âSTAMO",
        "#########################################################################",
        "",
        "// I. PROPIEDAD (OWNERSHIP)",
        "// Define qui√©n es responsable de la memoria (el Garbage Collector de Rust).",
        "",
        "// 1. Cada valor tiene un propietario (Owner).",
        "// 2. Solo puede haber UN propietario a la vez.",
        "// 3. Cuando el propietario sale del √°mbito (scope), el valor se elimina (drop).",
        "",
        "// CONSECUENCIA CLAVE: MOVIMIENTO (MOVE)",
        "// - Pasar un tipo sin Copy (String, Vec) transfiere la propiedad e invalida el original.",
        "// - Solo los tipos con Copy (i32, f64, bool) se copian.",
        "",
        "// -----------------------------------------------------------------------",
        "",
        "// II. PR√âSTAMO (BORROWING)",
        "// Permite usar un valor sin tomar su propiedad (pasando referencias).",
        "",
        "// üìú REGLA DE EXCLUSIVIDAD (CERO O UNO)",
        "// Solo puedes tener UNO de los siguientes pr√©stamos activos en un momento:",
        "",
        "// 1. CUALQUIER n√∫mero de Referencias Inmutables (&T)",
        "//    - Uso: Solo LECTURA.",
        "//    - Ventaja: Permite m√∫ltiples lectores simult√°neamente.",
        "",
        "// 2. UNA y solo UNA Referencia Mutable (&mut T)",
        "//    - Uso: LECTURA y ESCRITURA (Mutaci√≥n).",
        "//    - Ventaja: Garantiza Exclusividad Mutua para escribir (nadie m√°s puede leer ni escribir).",
        "",
        "// ‚ö†Ô∏è REGLA DE ORO",
        "// Nunca puedes tener una referencia &T y una &mut T activas al mismo tiempo.",
        "",
        "// ‚è±Ô∏è LIFETIME (Tiempo de Vida)",
        "// El compilador garantiza que una referencia (el pr√©stamo) nunca viva m√°s que el valor original (el propietario). ",
        "// Esto previene referencias a memoria ya liberada (Dangling References).",
        "",
        "// -----------------------------------------------------------------------",
        "",
        "// III. DESREFERENCIACI√ìN (El operador *)",
        "",
        "// üí° LECTURA (Deref Coercion)",
        "// Para leer, Rust a menudo aplica el * impl√≠citamente:",
        "// let valor = referencia + 5; // Rust lo convierte en (*referencia) + 5;",
        "",
        "// ‚úçÔ∏è ESCRITURA (Mutaci√≥n)",
        "// Para escribir o mutar a trav√©s de una referencia mutable, el * es OBLIGATORIO:",
        "// *referencia_mutable = 10;",
        "*/",
        "",
        "$0" 
    ],
    "description": "Inserta las reglas de Propiedad y Pr√©stamo de Rust."
  }
}

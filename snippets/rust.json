{
  "Funci贸n Main Principal": {
    "prefix": "main",
    "body": [
      "// ${1:Titulo}",
      "use std::io::{self, Write};",
      "fn main() {",
      "\t$2",
      "}"
    ],
    "description": "Inserta la funci贸n principal 'fn main() {}'"
  },
  "Cabecera de Archivo Rust": {
    "prefix": "header",
    "body": [
      "// Nombre: ${1:nombre}.rs",
      "// Autor: Ariana Uribe",
      "// Descripci贸n: ${2:Descripci贸n del archivo}",
      ""
    ],
    "description": "Plantilla de cabecera de archivo con nombre, autor y descripci贸n."
  },
  "forString": {
    "prefix": [
      "forstr"
    ],
    "body": [
      "for i in ${1:ini}..${2:end} {",
      "    println!(\"{}\", ${3:string}.chars().nth(i).unwrap());",
      "}"
    ],
    "description": [
      "For especial para recorrer caracteres de una cadena de texto."
    ]
  },
  "Rust Borrowing Rules": {
    "prefix": "rules",
    "body": [
      "/* ",
      "#########################################################################",
      "#                               REGLAS DE RUST: PROPIEDAD Y PRSTAMO",
      "#########################################################################",
      "",
      "// I. PROPIEDAD (OWNERSHIP)",
      "// Define qui茅n es responsable de la memoria (el Garbage Collector de Rust).",
      "",
      "// 1. Cada valor tiene un propietario (Owner).",
      "// 2. Solo puede haber UN propietario a la vez.",
      "// 3. Cuando el propietario sale del 谩mbito (scope), el valor se elimina (drop).",
      "",
      "// CONSECUENCIA CLAVE: MOVIMIENTO (MOVE)",
      "// - Pasar un tipo sin Copy (String, Vec) transfiere la propiedad e invalida el original.",
      "// - Solo los tipos con Copy (i32, f64, bool) se copian.",
      "",
      "// -----------------------------------------------------------------------",
      "",
      "// II. PRSTAMO (BORROWING)",
      "// Permite usar un valor sin tomar su propiedad (pasando referencias).",
      "",
      "//  REGLA DE EXCLUSIVIDAD (CERO O UNO)",
      "// Solo puedes tener UNO de los siguientes pr茅stamos activos en un momento:",
      "",
      "// 1. CUALQUIER n煤mero de Referencias Inmutables (&T)",
      "//    - Uso: Solo LECTURA.",
      "//    - Ventaja: Permite m煤ltiples lectores simult谩neamente.",
      "",
      "// 2. UNA y solo UNA Referencia Mutable (&mut T)",
      "//    - Uso: LECTURA y ESCRITURA (Mutaci贸n).",
      "//    - Ventaja: Garantiza Exclusividad Mutua para escribir (nadie m谩s puede leer ni escribir).",
      "",
      "// 锔 REGLA DE ORO",
      "// Nunca puedes tener una referencia &T y una &mut T activas al mismo tiempo.",
      "",
      "// 憋 LIFETIME (Tiempo de Vida)",
      "// El compilador garantiza que una referencia (el pr茅stamo) nunca viva m谩s que el valor original (el propietario). ",
      "// Esto previene referencias a memoria ya liberada (Dangling References).",
      "",
      "// -----------------------------------------------------------------------",
      "",
      "// III. DESREFERENCIACIN (El operador *)",
      "",
      "//  LECTURA (Deref Coercion)",
      "// Para leer, Rust a menudo aplica el * impl铆citamente:",
      "// let valor = referencia + 5; // Rust lo convierte en (*referencia) + 5;",
      "",
      "// 锔 ESCRITURA (Mutaci贸n)",
      "// Para escribir o mutar a trav茅s de una referencia mutable, el * es OBLIGATORIO:",
      "// *referencia_mutable = 10;",
      "*/",
      "",
      "$0"
    ],
    "description": "Inserta las reglas de Propiedad y Pr茅stamo de Rust."
  },
  "String": {
    "prefix": [
      "string"
    ],
    "body": [
      "String::from(\"${1:Texto}\");"
    ],
    "description": [
      "Crear una nueva cadena de texto."
    ]
  },
  "Match exception": {
    "prefix": [
      "matchEx"
    ],
    "body": [
      "match ${1:dato} {",
      "Ok(${2:input}) => { ${3:// codigo...} }",
      "Err(e) => { ${4:error... } }",
      "}"
    ],
    "description": [
      "match para excepciones."
    ]
  },
  "Match Some": {
    "prefix": [
      "matchSom"
    ],
    "body": [
      "match ${1:dato} {",
      "Some(${2:input}) => { ${3:codigo...} }",
      "None(e) => { ${4:Nada... } }",
      "}"
    ],
    "description": [
      "match para verificar existencia."
    ]
  },
  "Forrange": {
    "prefix": [
      "forrang"
    ],
    "body": [
      "for ${1:i} in ${2:0}..${3:n} {",
      "${4:// Codigo..}",
      "}"
    ],
    "description": [
      "For clasico desde i hasta n"
    ]
  },
  "Funcion de Struct": {
    "prefix": [
      "impl"
    ],
    "body": [
      "impl ${1:nombre de su estructura asociada.} {",
      "fn ${2:Nombre}(${3:&self}) -> ${4:Tipo a devolver} {",
      "${5:// Codigo...}",
      "}",
      "}"
    ],
    "description": [
      "Implementaci贸n de funci贸n asociada a un Struct."
    ]
  },
  "Declaracion de Enums": {
    "prefix": [
      "enum"
    ],
    "body": [
      "#[derive(Debug, PartialEq, Clone, Copy)]",
      "enum ${1:nombre} { ",
      "${2:dato}: ${3:variable}",
      "}"
    ],
    "description": [
      "Declaraci贸n completa de un enum."
    ]
  },
  "Funcion input": {
    "prefix": [
      "finput"
    ],
    "body": [
      "fn input () -> ${1:Tipo de salida} {",
      "loop {",
      "let mut input = String::new();",
      "let _ = io::stdin().read_line(&mut input); // <- Recibe los datos mediante la ref mutable.",
      "let n = input.trim(); // <- Los limpia",
      "match n.parse::<${1:Tipo de salida}>() // <- Los convierte al tipo necesario",
      "{",
      "// Comprueba los errores",
      "Ok( n ) => break n,",
      "Err( error ) => {",
      "println!(\"{error}\");",
      "println!(\"${2:Mensaje de error}\");",
      "},",
      "}}}"
    ],
    "description": [
      "Funcion para ingresar datos"
    ]
  },
  "Cabecera de Rust-Script": {
    "prefix": [
      "script"
    ],
    "body": [
      "#!/usr/bin/env rust-scriptrigger"
    ],
    "description": [
      "Cabecera para Rust Script"
    ]
  },
  "Linea de comando basica": {
    "prefix": [
      "commandb"
    ],
    "body": [
      "let ${1:var} = Command::new(\"${2:comando}\")",
      "    .arg(\"${3:argumento}\")",
      "    .status()",
      "    .expect(\"Fall贸 al ejecutar el comando\");"
    ],
    "description": [
      "Comando basico de terminal que indica si fue exitoso o no."
    ]
  },
  "Linea de comandos con output": {
    "prefix": [
      "commandOutput"
    ],
    "body": [
      "let ${1:var} = Command::new(\"${2:comando}\")",
      "    .arg(\"${3:argumento}\")",
      "    .output()",
      "    .expect(\"Fall贸 al ejecutar el comando\");"
    ],
    "description": [
      "Linea de comandos que captura la salida"
    ]
  },
  "Macro Rust Quick Print (No Newline)": {
    "prefix": [
      "myprint_macro"
    ],
    "body": [
      "use std::io::{self, Write};",
      "macro_rules! my_print {",
      "    (\\$(\\$arg:tt)*) => {",
      "        print!(\\$(\\$arg)*);",
      "        io::stdout().flush().expect(\"Fallo al vaciar el b煤fer\");",
      "    };",
      "}",
      "$0"
    ],
    "description": [
      "Macro para imprimir sin salto de l铆nea y forzar el flush inmediatamente."
    ]
  },
  "Just Impression (No Newline)": {
    "prefix": [
      "my_print"
    ],
    "body": [
      "my_print!(\"${1:Texto}\");"
    ],
    "description": [
      "descripcion"
    ]
  }
}
